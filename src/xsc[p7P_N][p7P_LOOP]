decoding_frameshift.c:  int          M    = gm->M;
decoding_frameshift.c:		            fwd->xmx[p7G_NXCELLS*(L-2) + p7G_C])) + gm->xsc[p7P_C][p7P_MOVE];
decoding_frameshift.c:  XMX_FS(0, p7G_N) = expf(bck->xmx[p7G_NXCELLS*0 + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_sc);
decoding_frameshift.c:        bck->xmx[p7G_NXCELLS*i + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_sc);
decoding_frameshift.c:        bck->xmx[p7G_NXCELLS*i + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_sc);
decoding_frameshift.c:        bck->xmx[p7G_NXCELLS*i + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_sc);
decoding_frameshift.c:	gm->xsc[p7P_N][p7P_LOOP] - overall_sc);
decoding_frameshift.c:	gm->xsc[p7P_J][p7P_LOOP] - overall_sc);
decoding_frameshift.c:	gm->xsc[p7P_C][p7P_LOOP] - overall_sc);
decoding_frameshift.c:		       fwd->xmx[p7G_NXCELLS*(L-2) + p7G_C])) + gm->xsc[p7P_C][p7P_MOVE];
decoding_frameshift.c:        n += expf(fwd->xmx[p7G_NXCELLS*(i-3) + p7G_N] + bck->xmx[p7G_NXCELLS*i + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        j += expf(fwd->xmx[p7G_NXCELLS*(i-3) + p7G_J] + bck->xmx[p7G_NXCELLS*i + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        c += expf(fwd->xmx[p7G_NXCELLS*(i-3) + p7G_C] + bck->xmx[p7G_NXCELLS*i + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:	 n += expf(bck->xmx[p7G_NXCELLS*i + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:         j += expf(bck->xmx[p7G_NXCELLS*i + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:         c += expf(bck->xmx[p7G_NXCELLS*i + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        n += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_N] + bck->xmx[p7G_NXCELLS*(i+1) + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        j += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_J] + bck->xmx[p7G_NXCELLS*(i+1) + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        c += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_C] + bck->xmx[p7G_NXCELLS*(i+1) + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:         n += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:         j += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:         c += expf(fwd->xmx[p7G_NXCELLS*(i-2) + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        n += expf(bck->xmx[p7G_NXCELLS*(i+1) + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        j += expf(bck->xmx[p7G_NXCELLS*(i+1) + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        c += expf(bck->xmx[p7G_NXCELLS*(i+1) + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        n += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_N] + bck->xmx[p7G_NXCELLS*(i+2) + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        j += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_J] + bck->xmx[p7G_NXCELLS*(i+2) + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        c += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_C] + bck->xmx[p7G_NXCELLS*(i+2) + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:	n += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        j += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
decoding_frameshift.c:        c += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
decoding_frameshift.c:  fwd = p7_gmx_Create(gm->M, L);  
decoding_frameshift.c:  bck = p7_gmx_Create(gm->M, L);
decoding_frameshift.c:  pp  = p7_gmx_Create(gm->M, L);
decoding_frameshift.c:  Mcs  = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
decoding_frameshift.c:  printf("# M    = %d\n", gm->M);
decoding_frameshift.c:  fwd = p7_gmx_Create(gm->M, sq->n);
decoding_frameshift.c:  bck = p7_gmx_Create(gm->M, sq->n);
decoding_frameshift.c:  dump_matrix_csv(stdout, bck, 1, sq->n, 1, gm->M);
emit.c:      xt[i][x] = exp(gm->xsc[i][x]);
emit.c:  ESL_ALLOC(pstart, sizeof(float) * (gm->M+1));
emit.c:  for (k = 1; k <= gm->M; k++)
emit.c:    pstart[k] = exp(p7P_TSC(gm, k-1, p7P_BM)) * (gm->M - k + 1); /* multiply p_ij by the number of exits j */
emit.c:  kstart = esl_rnd_FChoose(r, pstart, gm->M+1);          	 /* sample the starting position from that distribution */
emit.c:  kend   = kstart + esl_rnd_Roll(r, gm->M-kstart+1);           /* and the exit uniformly from possible exits for it */
evalues.c:    gm->evparam[p7_MLAMBDA] = lambda;
evalues.c:    gm->evparam[p7_VLAMBDA] = lambda;
evalues.c:    gm->evparam[p7_FLAMBDA] = lambda;
evalues.c:    gm->evparam[p7_MMU]     = mmu;
evalues.c:    gm->evparam[p7_VMU]     = vmu;
evalues.c:    gm->evparam[p7_FTAU]    = tau;
fm_ssv.c:    for (k = 1; k <= ssvdata->M; k++) // there's no need to bother keeping an entry starting at the last position (gm->M)
fsphmmert.c:            if ( esl_abc_XIsResidue(om->abc,j) &&  gm->rsc[j][(i) * p7P_NR     + p7P_MSC]   > max_score)   max_score   = gm->rsc[j][(i) * p7P_NR     + p7P_MSC];
fwdback_frameshift.c: *            <gm>, and DP matrix <gx> allocated for at least <gm->M>
fwdback_frameshift.c:  float const *tsc  = gm->tsc;
fwdback_frameshift.c:  int          M    = gm->M;
fwdback_frameshift.c:  XMX_FS(0,p7G_B) =  gm->xsc[p7P_N][p7P_MOVE];                   /* S->N->B, no N-tail   */
fwdback_frameshift.c:          XMX_FS(i,p7G_J) = p7_FLogsum(XMX_FS(i-3,p7G_J) + gm->xsc[p7P_J][p7P_LOOP],
fwdback_frameshift.c:		 		       XMX_FS(i,p7G_E) + gm->xsc[p7P_E][p7P_LOOP]);
fwdback_frameshift.c:	  XMX_FS(i,p7G_C) = p7_FLogsum(XMX_FS(i-3,p7G_C) + gm->xsc[p7P_C][p7P_LOOP],
fwdback_frameshift.c:				     XMX_FS(i,p7G_E) + gm->xsc[p7P_E][p7P_MOVE]);
fwdback_frameshift.c:	  XMX_FS(i,p7G_N) = XMX_FS(i-3,p7G_N) + gm->xsc[p7P_N][p7P_LOOP];
fwdback_frameshift.c:	   XMX_FS(i,p7G_J) = XMX_FS(i,p7G_E) + gm->xsc[p7P_E][p7P_LOOP]; 
fwdback_frameshift.c:	   XMX_FS(i,p7G_C) = XMX_FS(i,p7G_E) + gm->xsc[p7P_E][p7P_MOVE]; 
fwdback_frameshift.c:           XMX_FS(i,p7G_N) = gm->xsc[p7P_N][p7P_LOOP];
fwdback_frameshift.c:	XMX_FS(i,p7G_B) = p7_FLogsum(XMX_FS(i,p7G_N) + gm->xsc[p7P_N][p7P_MOVE],
fwdback_frameshift.c:				     XMX_FS(i,p7G_J) + gm->xsc[p7P_J][p7P_MOVE]);
fwdback_frameshift.c:	 			 + gm->xsc[p7P_C][p7P_MOVE];
fwdback_frameshift.c: *            <gm>, and DP matrix <gx> allocated for at least <gm->M>
fwdback_frameshift.c:  float const *tsc  = gm->tsc;
fwdback_frameshift.c:  int          M    = gm->M;
fwdback_frameshift.c:  XMX(L,p7G_C) = gm->xsc[p7P_C][p7P_MOVE];    /* C<-T          */
fwdback_frameshift.c:  XMX(L,p7G_E) = XMX(L,p7G_C) + gm->xsc[p7P_E][p7P_MOVE];  /* E<-C, no tail */
fwdback_frameshift.c:       XMX(i,p7G_J) = p7_FLogsum(XMX(i+3,p7G_J) + gm->xsc[p7P_J][p7P_LOOP],
fwdback_frameshift.c:		       		 XMX(i,p7G_B) + gm->xsc[p7P_J][p7P_MOVE]);
fwdback_frameshift.c:       XMX(i,p7G_C) = XMX(i+3,p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
fwdback_frameshift.c:       XMX(i,p7G_N) = p7_FLogsum( XMX(i+3,p7G_N) + gm->xsc[p7P_N][p7P_LOOP],
fwdback_frameshift.c:			          XMX(i,  p7G_B) + gm->xsc[p7P_N][p7P_MOVE]);
fwdback_frameshift.c:       XMX(i,p7G_J) = XMX(i,p7G_B) + gm->xsc[p7P_J][p7P_MOVE];
fwdback_frameshift.c:       XMX(i,p7G_C) = gm->xsc[p7P_C][p7P_MOVE];    /* C<-T          */
fwdback_frameshift.c:       XMX(i,p7G_N) = p7_FLogsum(gm->xsc[p7P_N][p7P_LOOP],
fwdback_frameshift.c:		                 XMX(i,  p7G_B) + gm->xsc[p7P_N][p7P_MOVE]);
fwdback_frameshift.c:     XMX(i,p7G_E) = p7_FLogsum(XMX(i, p7G_J)  + gm->xsc[p7P_E][p7P_LOOP],
fwdback_frameshift.c:			       XMX(i, p7G_C)  + gm->xsc[p7P_E][p7P_MOVE]);
fwdback_frameshift.c:  XMX(0,p7G_N) = p7_FLogsum(XMX(3, p7G_N) + gm->xsc[p7P_N][p7P_LOOP],
fwdback_frameshift.c:			    XMX(0, p7G_B) + gm->xsc[p7P_N][p7P_MOVE]);
fwdback_frameshift.c:  fwd = p7_gmx_Create(gm->M, L);
fwdback_frameshift.c:  bck = p7_gmx_Create(gm->M, L);
fwdback_frameshift.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
fwdback_frameshift.c:  printf("# M    = %d\n",   gm->M);
fwdback_frameshift.c:  if ((fwd    = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
fwdback_frameshift.c:  if ((bck    = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
fwdback_frameshift.c:  P7_GMX   *gx = p7_gmx_Create(gm->M, 100);
fwdback_frameshift.c:      if (p7_gmx_GrowTo(gx, gm->M, sq->n)            != eslOK) esl_fatal("failed to reallocate gmx");
fwdback_frameshift.c:  fwd = p7_gmx_Create(gm->M, sq->n);
fwdback_frameshift.c:  bck = p7_gmx_Create(gm->M, sq->n);
fwdback_frameshift.c:      p7_gmx_GrowTo(fwd, gm->M, sq->n);
fwdback_frameshift.c:      p7_gmx_GrowTo(bck, gm->M, sq->n);
generic_decoding.c:  int          M    = gm->M;
generic_decoding.c:  float        overall_sc = fwd->xmx[p7G_NXCELLS*L + p7G_C] + gm->xsc[p7P_C][p7P_MOVE];
generic_decoding.c:      XMX(i,p7G_N) = expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_N] + bck->xmx[p7G_NXCELLS*i + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_sc);
generic_decoding.c:      XMX(i,p7G_J) = expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_J] + bck->xmx[p7G_NXCELLS*i + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_sc);
generic_decoding.c:      XMX(i,p7G_C) = expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_C] + bck->xmx[p7G_NXCELLS*i + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_sc);
generic_decoding.c:  float overall_logp = fwd->xmx[p7G_NXCELLS*L + p7G_C] + gm->xsc[p7P_C][p7P_MOVE];
generic_decoding.c:      njcp  = expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_N] + bck->xmx[p7G_NXCELLS*i + p7G_N] + gm->xsc[p7P_N][p7P_LOOP] - overall_logp);
generic_decoding.c:      njcp += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_J] + bck->xmx[p7G_NXCELLS*i + p7G_J] + gm->xsc[p7P_J][p7P_LOOP] - overall_logp);
generic_decoding.c:      njcp += expf(fwd->xmx[p7G_NXCELLS*(i-1) + p7G_C] + bck->xmx[p7G_NXCELLS*i + p7G_C] + gm->xsc[p7P_C][p7P_LOOP] - overall_logp);
generic_decoding.c:  ddef->L = gm->L;
generic_decoding.c:  fwd = p7_gmx_Create(gm->M, L);  
generic_decoding.c:  bck = p7_gmx_Create(gm->M, L);
generic_decoding.c:  pp  = p7_gmx_Create(gm->M, L);
generic_decoding.c:  Mcs  = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
generic_decoding.c:  printf("# M    = %d\n", gm->M);
generic_decoding.c:  fwd = p7_gmx_Create(gm->M, sq->n);
generic_decoding.c:  bck = p7_gmx_Create(gm->M, sq->n);
generic_decoding.c:  dump_matrix_csv(stdout, bck, 1, sq->n, 1, gm->M);
generic_fwdback.c: *            <gm>, and DP matrix <gx> allocated for at least <gm->M>
generic_fwdback.c:  float const *tsc  = gm->tsc;
generic_fwdback.c:  int          M    = gm->M;
generic_fwdback.c:  XMX(0,p7G_B) = gm->xsc[p7P_N][p7P_MOVE];                    /* S->N->B, no N-tail   */
generic_fwdback.c:      float const *rsc = gm->rsc[dsq[i]];
generic_fwdback.c:      XMX(i,p7G_J) = p7_FLogsum(XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP],
generic_fwdback.c:				XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP]);
generic_fwdback.c:      XMX(i,p7G_C) = p7_FLogsum(XMX(i-1,p7G_C) + gm->xsc[p7P_C][p7P_LOOP],
generic_fwdback.c:				XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_MOVE]);
generic_fwdback.c:      XMX(i,p7G_N) = XMX(i-1,p7G_N) + gm->xsc[p7P_N][p7P_LOOP];
generic_fwdback.c:      XMX(i,p7G_B) = p7_FLogsum(XMX(i,  p7G_N) + gm->xsc[p7P_N][p7P_MOVE],
generic_fwdback.c:				XMX(i,  p7G_J) + gm->xsc[p7P_J][p7P_MOVE]);
generic_fwdback.c:  if (opt_sc != NULL) *opt_sc = XMX(L,p7G_C) + gm->xsc[p7P_C][p7P_MOVE];
generic_fwdback.c: *            <gm>, and DP matrix <gx> allocated for at least <gm->M>
generic_fwdback.c:  float const *tsc  = gm->tsc;
generic_fwdback.c:  int          M    = gm->M;
generic_fwdback.c:  XMX(L,p7G_C) = gm->xsc[p7P_C][p7P_MOVE];                 /* C<-T          */
generic_fwdback.c:  XMX(L,p7G_E) = XMX(L,p7G_C) + gm->xsc[p7P_E][p7P_MOVE];  /* E<-C, no tail */
generic_fwdback.c:      rsc = gm->rsc[dsq[i+1]];
generic_fwdback.c:      XMX(i,p7G_J) = p7_FLogsum( XMX(i+1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP],
generic_fwdback.c:				 XMX(i,  p7G_B) + gm->xsc[p7P_J][p7P_MOVE]);
generic_fwdback.c:      XMX(i,p7G_C) = XMX(i+1,p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
generic_fwdback.c:      XMX(i,p7G_E) = p7_FLogsum( XMX(i, p7G_J)  + gm->xsc[p7P_E][p7P_LOOP],
generic_fwdback.c:				 XMX(i, p7G_C)  + gm->xsc[p7P_E][p7P_MOVE]);
generic_fwdback.c:      XMX(i,p7G_N) = p7_FLogsum( XMX(i+1,p7G_N) + gm->xsc[p7P_N][p7P_LOOP],
generic_fwdback.c:				 XMX(i,  p7G_B) + gm->xsc[p7P_N][p7P_MOVE]);
generic_fwdback.c:  rsc = gm->rsc[dsq[1]];
generic_fwdback.c:  XMX(i,p7G_N) = p7_FLogsum( XMX(1, p7G_N) + gm->xsc[p7P_N][p7P_LOOP],
generic_fwdback.c:			     XMX(0, p7G_B) + gm->xsc[p7P_N][p7P_MOVE]);
generic_fwdback.c: *            <gm>, and DP matrix <mx> allocated for at least <gm->M>
generic_fwdback.c:    for (k = 1 ; k <= gm->M; k++)
generic_fwdback.c:  gx->M = gm->M;
generic_fwdback.c:  fwd = p7_gmx_Create(gm->M, L);
generic_fwdback.c:  bck = p7_gmx_Create(gm->M, L);
generic_fwdback.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
generic_fwdback.c:  printf("# M    = %d\n",   gm->M);
generic_fwdback.c:  if ((fwd    = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
generic_fwdback.c:  if ((bck    = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
generic_fwdback.c:  P7_GMX   *gx = p7_gmx_Create(gm->M, 100);
generic_fwdback.c:      if (p7_gmx_GrowTo(gx, gm->M, sq->n)            != eslOK) esl_fatal("failed to reallocate gmx");
generic_fwdback.c:  fwd = p7_gmx_Create(gm->M, sq->n);
generic_fwdback.c:  bck = p7_gmx_Create(gm->M, sq->n);
generic_fwdback.c:      p7_gmx_GrowTo(fwd, gm->M, sq->n);
generic_fwdback.c:      p7_gmx_GrowTo(bck, gm->M, sq->n);
generic_fwdback_banded.c:  float const *tsc    = gm->tsc;		 /* sets up TSC() macro, access to profile's transitions */
generic_fwdback_banded.c:      kap = kbp = gm->M+1;   
generic_fwdback_banded.c:      xN  = xN + (ia - last_ib - 1) * gm->xsc[p7P_N][p7P_LOOP];
generic_fwdback_banded.c:      xJ  = xJ + (ia - last_ib - 1) * gm->xsc[p7P_J][p7P_LOOP];
generic_fwdback_banded.c:      xB  = p7_FLogsum( xN + gm->xsc[p7P_N][p7P_MOVE], xJ + gm->xsc[p7P_J][p7P_MOVE]);
generic_fwdback_banded.c:      xC  = xC + (ia - last_ib - 1) * gm->xsc[p7P_C][p7P_LOOP];
generic_fwdback_banded.c:	  rsc      = gm->rsc[dsq[i]];   /* sets up MSC(k), ISC(k) residue scores for this row i */
generic_fwdback_banded.c:	  kbc2     = (kbc == gm->M ? kbc-1 : kbc); /* a "do_M" flag works too, but this way we avoid an if statement */
generic_fwdback_banded.c:	  *xpc++ = xN = xN + gm->xsc[p7P_N][p7P_LOOP];
generic_fwdback_banded.c:	  *xpc++ = xJ = p7_FLogsum( xJ + gm->xsc[p7P_J][p7P_LOOP],  xE + gm->xsc[p7P_E][p7P_MOVE]);
generic_fwdback_banded.c:	  *xpc++ = xB = p7_FLogsum( xJ + gm->xsc[p7P_J][p7P_MOVE],  xN + gm->xsc[p7P_N][p7P_MOVE]);
generic_fwdback_banded.c:	  *xpc++ = xC = p7_FLogsum( xE + gm->xsc[p7P_E][p7P_MOVE],  xC + gm->xsc[p7P_C][p7P_LOOP]);
generic_fwdback_banded.c:  if (opt_sc != NULL) *opt_sc = xC + (L-last_ib) *  gm->xsc[p7P_C][p7P_LOOP] + gm->xsc[p7P_C][p7P_MOVE];
generic_fwdback_banded.c:  bnd = p7_gbands_Create(L, gm->M);
generic_fwdback_banded.c:  if (L < gm->M) p7_Fail("for now, L must be >=M, because we make a single band");
generic_fwdback_banded.c:  base = (L-gm->M) / 2;
generic_fwdback_banded.c:  for (k = 1; k <= gm->M; k++)
generic_fwdback_banded.c:    p7_gbands_Append(bnd, k+base, ESL_MAX(1,k-W), ESL_MIN(gm->M,k+W));
generic_fwdback_banded.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
generic_fwdback_banded.c:  printf("# M    = %d\n",   gm->M);
generic_fwdback_chk.c:  const float *tsc = gm->tsc;
generic_fwdback_chk.c:  const float *rsc = gm->rsc[dsq[i]] + p7P_NR; /* +NR skips _0, ahead to _1 */
generic_fwdback_chk.c:  int      M = gm->M;
generic_fwdback_chk.c:  dpc[p7GC_N]  =              dpp[p7GC_N] + gm->xsc[p7P_N][p7P_LOOP];                                             /* N state = N(i-1)->N(i)      */
generic_fwdback_chk.c:  dpc[p7GC_JJ] =              dpp[p7GC_J] + gm->xsc[p7P_J][p7P_LOOP];                                             /* J->J emission partial path  */
generic_fwdback_chk.c:  dpc[p7GC_J]  = p7_FLogsum(  dpc[p7GC_JJ],                           dpc[p7GC_E] + gm->xsc[p7P_E][p7P_LOOP]);    /* J state = JJ + E->J         */
generic_fwdback_chk.c:  dpc[p7GC_B]  = p7_FLogsum(  dpc[p7GC_N] + gm->xsc[p7P_N][p7P_MOVE], dpc[p7GC_J] + gm->xsc[p7P_J][p7P_MOVE]);    /* B state = N->B + J->B       */
generic_fwdback_chk.c:  dpc[p7GC_CC] =              dpp[p7GC_C] + gm->xsc[p7P_C][p7P_LOOP];                                             /* C->C emission partial path  */
generic_fwdback_chk.c:  dpc[p7GC_C]  = p7_FLogsum(  dpc[p7GC_CC],                           dpc[p7GC_E] + gm->xsc[p7P_E][p7P_MOVE]);    /* C state = CC + E->C         */
generic_fwdback_chk.c: *            appropriately for the <gm->M> by <L> comparison, either
generic_fwdback_chk.c:  int    M   = gm->M;
generic_fwdback_chk.c:  *dpc++ = gm->xsc[p7P_N][p7P_MOVE]; /* B; from N->B only        */
generic_fwdback_chk.c:  if (opt_sc) *opt_sc = gxc->dp[gxc->R0+gxc->R-1][(M+1)*p7G_NSCELLS + p7GC_C] + gm->xsc[p7P_C][p7P_MOVE];
generic_fwdback_chk.c:  const float * const tsc = gm->tsc;             /* both the parameters and the pointer itself are constant */
generic_fwdback_chk.c:  const float * const rsc = gm->rsc[dsq[i+1]];
generic_fwdback_chk.c:  int                 M   = gm->M;
generic_fwdback_chk.c:  XMR(dpc,p7GC_C) =  XMR(dpc,p7GC_CC) =  XMR(dpp,p7GC_C) + gm->xsc[p7P_C][p7P_LOOP];
generic_fwdback_chk.c:  XMR(dpc,p7GC_J)  = XMR(dpc,p7GC_JJ) = p7_FLogsum( XMR(dpp,p7GC_J) + gm->xsc[p7P_J][p7P_LOOP],  XMR(dpc,p7GC_B) + gm->xsc[p7P_J][p7P_MOVE]);
generic_fwdback_chk.c:  XMR(dpc,p7GC_N)  = p7_FLogsum( XMR(dpp,p7GC_N) + gm->xsc[p7P_N][p7P_LOOP],  XMR(dpc,p7GC_B) + gm->xsc[p7P_N][p7P_MOVE]);
generic_fwdback_chk.c:  XMR(dpc,p7GC_E)  = p7_FLogsum( XMR(dpc,p7GC_J) + gm->xsc[p7P_E][p7P_LOOP],  XMR(dpc,p7GC_C) + gm->xsc[p7P_E][p7P_MOVE]);
generic_fwdback_chk.c:  float const *tsc  = gm->tsc;
generic_fwdback_chk.c:  int          M    = gm->M;
generic_fwdback_chk.c:  float        overall_sc = gxc->dp[gxc->R0+gxc->R-1][(M+1)*p7G_NSCELLS + p7GC_C] + gm->xsc[p7P_C][p7P_MOVE];
generic_fwdback_chk.c:  XMR(bck, p7GC_C)  = gm->xsc[p7P_C][p7P_MOVE];                    /* C<-T */
generic_fwdback_chk.c:  XMR(bck, p7GC_CC) = gm->xsc[p7P_C][p7P_MOVE];                    /* CC<-T */
generic_fwdback_chk.c:  XMR(bck, p7GC_E)  = XMR(bck, p7GC_C) + gm->xsc[p7P_E][p7P_MOVE]; /* E<-C, no tail */
generic_fwdback_chk.c:  rsc = gm->rsc[dsq[1]];
generic_fwdback_chk.c:  XMR(bck,p7GC_N) = p7_FLogsum( XMR(dpp, p7GC_N) + gm->xsc[p7P_N][p7P_LOOP],
generic_fwdback_chk.c:				XMR(bck, p7GC_B) + gm->xsc[p7P_N][p7P_MOVE]);
generic_fwdback_chk.c:  gxc = p7_gmxchk_Create(gm->M, L, ESL_MBYTES(32));
generic_fwdback_chk.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
generic_fwdback_chk.c:  printf("# M    = %d\n",   gm->M);
generic_fwdback_chk.c:  if ( p7_gmx_GrowTo(gx, gm->M, L)                      != eslOK) esl_fatal(msg);
generic_fwdback_chk.c:  if ( p7_gmxchk_GrowTo(gxc, gm->M, L)                  != eslOK) esl_fatal(msg);
generic_fwdback_chk.c:  P7_GMX    *gx    = p7_gmx_Create(gm->M, 100);
generic_fwdback_chk.c:  P7_GMXCHK *gxc   = p7_gmxchk_Create(gm->M, 100, ESL_MBYTES(32));
generic_fwdback_chk.c:  P7_GMX    *gx    = p7_gmx_Create(gm->M, 100);
generic_fwdback_chk.c:  P7_GMXCHK *gxc   = p7_gmxchk_Create(gm->M, 100, ESL_MBYTES(32));
generic_fwdback_chk.c:  fwd = p7_gmx_Create(gm->M, 400);
generic_fwdback_chk.c:  bck = p7_gmx_Create(gm->M, 400);
generic_fwdback_chk.c:  gxc = p7_gmxchk_Create(gm->M, 400, ESL_MBYTES(32));
generic_fwdback_chk.c:      p7_gmx_GrowTo   (fwd, gm->M, sq->n);
generic_fwdback_chk.c:      p7_gmx_GrowTo   (bck, gm->M, sq->n);
generic_fwdback_chk.c:      p7_gmxchk_GrowTo(gxc, gm->M, sq->n);
generic_fwdback_rescaled.c:      fwd    = p7_gmx_Create(gm->M,    400);
generic_fwdback_rescaled.c:	  p7_gmx_GrowTo(fwd,    gm->M,    sq->n);
generic_fwdback_rescaled.c:		 gm->name, sq->name, fsc, fscref,
generic_fwdback_rescaled.c:  float const *tsc = gm->tsc;
generic_fwdback_rescaled.c:  int          M   = gm->M;
generic_fwdback_rescaled.c:  XMX(0,p7G_B) = gm->xsc[p7P_N][p7P_MOVE];    /* S->N->B, 1*t_NB */
generic_fwdback_rescaled.c:      float const *rsc = gm->rsc[dsq[i]];
generic_fwdback_rescaled.c:      XMX(i,p7G_J) =   XMX(i-1,p7G_J) * gm->xsc[p7P_J][p7P_LOOP]
generic_fwdback_rescaled.c:                     + XMX(i,  p7G_E) * gm->xsc[p7P_E][p7P_LOOP];
generic_fwdback_rescaled.c:      XMX(i,p7G_C) =   XMX(i-1,p7G_C) * gm->xsc[p7P_C][p7P_LOOP]
generic_fwdback_rescaled.c:		     + XMX(i,  p7G_E) * gm->xsc[p7P_E][p7P_MOVE];
generic_fwdback_rescaled.c:      XMX(i,p7G_N) =   XMX(i-1,p7G_N) * gm->xsc[p7P_N][p7P_LOOP];
generic_fwdback_rescaled.c:      XMX(i,p7G_B) =   XMX(i,  p7G_N) * gm->xsc[p7P_N][p7P_MOVE]
generic_fwdback_rescaled.c:		     + XMX(i,  p7G_J) * gm->xsc[p7P_J][p7P_MOVE];
generic_fwdback_rescaled.c:  if (opt_sc != NULL) *opt_sc = log(XMX(L,p7G_C) * gm->xsc[p7P_C][p7P_MOVE]) + totscale;
generic_fwdback_rescaled.c:  if (gm->abc->type != hmm->abc->type) ESL_XEXCEPTION(eslEINVAL, "HMM and profile alphabet don't match");
generic_fwdback_rescaled.c:  if (hmm->M > gm->allocM)             ESL_XEXCEPTION(eslEINVAL, "profile too small to hold HMM");
generic_fwdback_rescaled.c:  gm->M                = hmm->M;
generic_fwdback_rescaled.c:  gm->max_length       = hmm->max_length;
generic_fwdback_rescaled.c:  gm->mode             = p7_NO_MODE;
generic_fwdback_rescaled.c:  gm->roff             = -1;
generic_fwdback_rescaled.c:  gm->eoff             = -1;
generic_fwdback_rescaled.c:  gm->offs[p7_MOFFSET] = -1;
generic_fwdback_rescaled.c:  gm->offs[p7_FOFFSET] = -1;
generic_fwdback_rescaled.c:  gm->offs[p7_POFFSET] = -1;
generic_fwdback_rescaled.c:  if (gm->name != NULL) free(gm->name);
generic_fwdback_rescaled.c:  if (gm->acc  != NULL) free(gm->acc);
generic_fwdback_rescaled.c:  if (gm->desc != NULL) free(gm->desc);
generic_fwdback_rescaled.c:  if ((status = esl_strdup(hmm->name,   -1, &(gm->name))) != eslOK) goto ERROR;
generic_fwdback_rescaled.c:  if ((status = esl_strdup(hmm->acc,    -1, &(gm->acc)))  != eslOK) goto ERROR;
generic_fwdback_rescaled.c:  if ((status = esl_strdup(hmm->desc,   -1, &(gm->desc))) != eslOK) goto ERROR;
generic_fwdback_rescaled.c:  if (hmm->flags & p7H_RF)    strcpy(gm->rf,        hmm->rf);
generic_fwdback_rescaled.c:  if (hmm->flags & p7H_MMASK) strcpy(gm->mm,        hmm->mm);
generic_fwdback_rescaled.c:  if (hmm->flags & p7H_CONS)  strcpy(gm->consensus, hmm->consensus); /* must be present, actually, so the flag test is just for symmetry w/ other optional HMM fields */
generic_fwdback_rescaled.c:  if (hmm->flags & p7H_CS)    strcpy(gm->cs,        hmm->cs);
generic_fwdback_rescaled.c:  for (z = 0; z < p7_NEVPARAM; z++) gm->evparam[z] = hmm->evparam[z];
generic_fwdback_rescaled.c:  for (z = 0; z < p7_NCUTOFFS; z++) gm->cutoff[z]  = hmm->cutoff[z];
generic_fwdback_rescaled.c:  for (z = 0; z < p7_MAXABET;  z++) gm->compo[z]   = hmm->compo[z];
generic_fwdback_rescaled.c:  pmove = (2.0f + gm->nj) / ((float) L + 2.0f + gm->nj); /* 2/(L+2) for sw; 3/(L+3) for fs */
generic_fwdback_rescaled.c:  gm->xsc[p7P_N][p7P_LOOP] =  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = ploop;
generic_fwdback_rescaled.c:  gm->xsc[p7P_N][p7P_MOVE] =  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = pmove;
generic_fwdback_rescaled.c:  gm->L = L;
generic_fwdback_rescaled.c:  gm->mode = mode;
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->tsc, p7P_NTRANS, 0.0f);     /* node 0 nonexistent, has no transitions  */
generic_fwdback_rescaled.c:  if (gm->M > 1) {
generic_fwdback_rescaled.c:  for (x = 0; x < gm->abc->Kp; x++) {        
generic_fwdback_rescaled.c:  x = esl_abc_XGetGap(gm->abc);	                       /* no emission can emit/score gap characters */
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0f);
generic_fwdback_rescaled.c:  x = esl_abc_XGetMissing(gm->abc);	                      /* no emission can emit/score missing data characters */
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0f);
generic_fwdback_rescaled.c:    gm->xsc[p7P_E][p7P_MOVE] = 0.5f;
generic_fwdback_rescaled.c:    gm->xsc[p7P_E][p7P_LOOP] = 0.5f;
generic_fwdback_rescaled.c:    gm->nj                   = 1.0f;
generic_fwdback_rescaled.c:    gm->xsc[p7P_E][p7P_MOVE] = 1.0f;   
generic_fwdback_rescaled.c:    gm->xsc[p7P_E][p7P_LOOP] = 0.0f;
generic_fwdback_rescaled.c:    gm->nj                   = 0.0f;
generic_fwdback_rescaled.c:  for (k = 1; k < gm->M; k++) 
generic_fwdback_rescaled.c:      tp = gm->tsc + k * p7P_NTRANS;
generic_fwdback_rescaled.c:      rp = gm->rsc[x] + k * p7P_NR;
generic_fwdback_rescaled.c:  for (x = 0; x < gm->abc->Kp; x++)
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->K)    = 0.0f; /* gap symbol */
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-2) = 0.0f; /* nonresidue symbol */
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-1) = 0.0f; /* missing data symbol */
generic_fwdback_rescaled.c:  gm->L = 0;			/* force ReconfigLengthInOdds to reconfig */
generic_fwdback_rescaled.c:  gm->mode = p7_UNIGLOCAL;
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->tsc, p7P_NTRANS, 0.0f);     /* node 0 nonexistent, has no transitions  */
generic_fwdback_rescaled.c:  if (gm->M > 1) {
generic_fwdback_rescaled.c:  for (x = 0; x < gm->abc->Kp; x++) {        
generic_fwdback_rescaled.c:  x = esl_abc_XGetGap(gm->abc);	                       /* no emission can emit/score gap characters */
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0f);
generic_fwdback_rescaled.c:  x = esl_abc_XGetMissing(gm->abc);	                      /* no emission can emit/score missing data characters */
generic_fwdback_rescaled.c:  esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0f);
generic_fwdback_rescaled.c:  gm->xsc[p7P_E][p7P_MOVE] = 1.0f;   
generic_fwdback_rescaled.c:  gm->xsc[p7P_E][p7P_LOOP] = 0.0f;
generic_fwdback_rescaled.c:  gm->nj                   = 0.0f;
generic_fwdback_rescaled.c:  for (k = 1; k < gm->M; k++)
generic_fwdback_rescaled.c:      tp      = gm->tsc + k * p7P_NTRANS;
generic_fwdback_rescaled.c:      for (k = 1; k < gm->M; k++)
generic_fwdback_rescaled.c:      rp = gm->rsc[x] + k * p7P_NR;
generic_fwdback_rescaled.c:  for (x = 0; x < gm->abc->Kp; x++)
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->K)    = 0.0f; /* gap symbol */
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-2) = 0.0f; /* nonresidue symbol */
generic_fwdback_rescaled.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-1) = 0.0f; /* missing data symbol */
generic_fwdback_rescaled.c:  gm->L = 0;			/* force ReconfigLengthInOdds to reconfig */
generic_msv.c:  float        tbmk  = logf(     2.0f / ((float) gm->M * (float) (gm->M+1)));
generic_msv.c:  for (k = 0; k <= gm->M; k++)
generic_msv.c:	  float const *rsc = gm->rsc[dsq[i]];
generic_msv.c:      for (k = 1; k <= gm->M; k++) 
generic_msv.c:  gx->M = gm->M;
generic_msv.c:   * - the transitions are parameterized based on window length (gm->max_length), not target length.
generic_msv.c:  float        tloop = logf((float) gm->max_length / (float) (gm->max_length+3));
generic_msv.c:  float        tmove = logf(     3.0f / (float) (gm->max_length+3));
generic_msv.c:  float        tbmk  = logf(     2.0f / ((float) gm->M * (float) (gm->M+1)));
generic_msv.c:  float 	   tloop_total = tloop * gm->max_length;
generic_msv.c:  float invP = esl_gumbel_invsurv(P, gm->evparam[p7_MMU],  gm->evparam[p7_MLAMBDA]);
generic_msv.c:  p7_bg_SetLength(bg, gm->max_length);
generic_msv.c:  p7_ReconfigLength(gm, gm->max_length);
generic_msv.c:  p7_bg_NullOne  (bg, dsq, gm->max_length, &nullsc);
generic_msv.c:  for (k = 0; k <= gm->M; k++)
generic_msv.c:	  float const *rsc = gm->rsc[dsq[i]];
generic_msv.c:	  for (k = 1; k <= gm->M; k++)
generic_msv.c:	    target_start =  ESL_MAX(1, i - gm->max_length + 1);
generic_msv.c:	    //target_end   =  ESL_MIN(L, i + gm->max_length - 1);
generic_msv.c:	    p7_hmmwindow_new(windowlist, 0, target_start, 0, gm->M/2, 1, XMX(i,p7G_C), p7_NOCOMPLEMENT, L);
generic_msv.c:		  for (k = 0; k <= gm->M; k++)
generic_msv.c:  gx = p7_gmx_Create(gm->M, L);
generic_msv.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
generic_msv.c:  printf("# M    = %d\n",   gm->M);
generic_msv.c:  if ((gx     = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
generic_msv.c:  fwd = p7_gmx_Create(gm->M, sq->n);
generic_msv.c:      p7_gmx_GrowTo(fwd, gm->M, sq->n); 
generic_msv.c:      lnP      =  esl_gumbel_logsurv(seqscore,  gm->evparam[p7_MMU],  gm->evparam[p7_MLAMBDA]);
generic_null2.c:  int      M      = gm->M;
generic_null2.c:  esl_vec_FSet(null2, gm->abc->K, -eslINFINITY);
generic_null2.c:  for (x = 0; x < gm->abc->K; x++)
generic_null2.c:  esl_vec_FExp (null2, gm->abc->K);
generic_null2.c:  esl_abc_FAvgScVec(gm->abc, null2); /* does not set gap, nonres, missing  */
generic_null2.c:  null2[gm->abc->K]    = 1.0;        /* gap character    */
generic_null2.c:  null2[gm->abc->Kp-2] = 1.0;	     /* nonresidue "*"   */
generic_null2.c:  null2[gm->abc->Kp-1] = 1.0;	     /* missing data "~" */
generic_null2.c:  int      M    = gm->M;
generic_null2.c:  esl_vec_FSet(null2, gm->abc->K, 0.0);
generic_null2.c:  for (x = 0; x < gm->abc->K; x++)
generic_null2.c:  esl_abc_FAvgScVec(gm->abc, null2);
generic_null2.c:  null2[gm->abc->K]    = 1.0;        /* gap character    */
generic_null2.c:  null2[gm->abc->Kp-2] = 1.0;	     /* nonresidue "*"   */
generic_null2.c:  null2[gm->abc->Kp-1] = 1.0;	     /* missing data "~" */
generic_null2.c:  gx1 = p7_gmx_Create(gm->M, L);  
generic_null2.c:  gx2 = p7_gmx_Create(gm->M, L);
generic_null2.c:  Mcs  = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
generic_null2.c:  printf("# M    = %d\n", gm->M);
generic_null2.c:  esl_rsq_xfIID(r, bg->f, gm->abc->K, L, dsq); /* sample a random digital seq of length L */
generic_null2.c:  for (x = 0; x < gm->abc->K; x++)
generic_null2.c:  sum = esl_vec_FSum(null2, gm->abc->K);
generic_null2.c:  fwd  = p7_gmx_Create(gm->M, L);
generic_null2.c:  bck  = p7_gmx_Create(gm->M, L);
generic_optacc.c: *            <gm->M> by <pp->L> comparison. The routine fills this in
generic_optacc.c: *            gx    - RESULT: caller provided DP matrix for <gm->M> by <L> 
generic_optacc.c:  float const *tsc  = gm->tsc;
generic_optacc.c:  int          M    = gm->M;
generic_optacc.c:      t1 = ( (gm->xsc[p7P_J][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t2 = ( (gm->xsc[p7P_E][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t1 = ( (gm->xsc[p7P_C][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t2 = ( (gm->xsc[p7P_E][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t1 = ( (gm->xsc[p7P_N][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t1 = ( (gm->xsc[p7P_N][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      t2 = ( (gm->xsc[p7P_J][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  tr->M = gm->M;
generic_optacc.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
generic_optacc.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
generic_optacc.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
generic_optacc.c:  float  t1   =  ( (gm->xsc[p7P_C][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  float  t2   =  ( (gm->xsc[p7P_E][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  float  t1   = ( (gm->xsc[p7P_J][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  float  t2   = ( (gm->xsc[p7P_E][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:      *ret_k = gm->M;
generic_optacc.c:      return ((MMX(i,gm->M) >= DMX(i,gm->M)) ? p7T_M : p7T_D);
generic_optacc.c:  for (k = 1; k <= gm->M; k++)
generic_optacc.c:  float t1 = ( (gm->xsc[p7P_N][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  float t2 = ( (gm->xsc[p7P_J][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
generic_optacc.c:  gx1 = p7_gmx_Create(gm->M, L);
generic_optacc.c:  gx2 = p7_gmx_Create(gm->M, L);
generic_optacc.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
generic_optacc.c:  printf("# M    = %d\n", gm->M);
generic_optacc.c:  gx1 = p7_gmx_Create(gm->M, sq->n);
generic_optacc.c:  gx2 = p7_gmx_Create(gm->M, sq->n);
generic_stotrace.c:  int     M   = gm->M;
generic_stotrace.c:  float const *tsc  = gm->tsc;
generic_stotrace.c:	sc[0] = XMX(i-1, p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
generic_stotrace.c:	sc[1] = XMX(i,   p7G_E) + gm->xsc[p7P_E][p7P_MOVE];
generic_stotrace.c:	sc[0] = XMX(i, p7G_N) + gm->xsc[p7P_N][p7P_MOVE];
generic_stotrace.c:	sc[1] = XMX(i, p7G_J) + gm->xsc[p7P_J][p7P_MOVE];
generic_stotrace.c:	sc[0] = XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];
generic_stotrace.c:	sc[1] = XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP];
generic_stotrace.c:  tr->M = gm->M;
generic_stotrace.c:  fwd = p7_gmx_Create(gm->M, L);
generic_stotrace.c:  if ((gx     = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
generic_stotrace.c:  fwd = p7_gmx_Create(gm->M, sq->n);
generic_viterbi.c: *            by <gm->M> cells; calculate the maximum scoring path by
generic_viterbi.c:  float const *tsc  = gm->tsc;
generic_viterbi.c:  int          M    = gm->M;
generic_viterbi.c:  XMX(0,p7G_B) = gm->xsc[p7P_N][p7P_MOVE];                    /* S->N->B, no N-tail   */
generic_viterbi.c:  for (k = 0; k <= gm->M; k++)
generic_viterbi.c:      float const *rsc = gm->rsc[dsq[i]];
generic_viterbi.c:      for (k = 1; k < gm->M; k++) 
generic_viterbi.c:      sc           =             XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];   /* J->J */
generic_viterbi.c:      XMX(i,p7G_J) = ESL_MAX(sc, XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP]);  /* E->J is E's "loop" */
generic_viterbi.c:      sc           =             XMX(i-1,p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
generic_viterbi.c:      XMX(i,p7G_C) = ESL_MAX(sc, XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_MOVE]);
generic_viterbi.c:      XMX(i,p7G_N) = XMX(i-1,p7G_N) + gm->xsc[p7P_N][p7P_LOOP];
generic_viterbi.c:      sc           =             XMX(i,p7G_N) + gm->xsc[p7P_N][p7P_MOVE];   /* N->B is N's move */
generic_viterbi.c:      XMX(i,p7G_B) = ESL_MAX(sc, XMX(i,p7G_J) + gm->xsc[p7P_J][p7P_MOVE]);  /* J->B is J's move */
generic_viterbi.c:  if (opt_sc != NULL) *opt_sc = XMX(L,p7G_C) + gm->xsc[p7P_C][p7P_MOVE];
generic_viterbi.c:  gx->M = gm->M;
generic_viterbi.c: *            by <gm->M> cells; calculates the Viterbi score for
generic_viterbi.c:  float const *tsc  = gm->tsc;
generic_viterbi.c:  int          M    = gm->M;
generic_viterbi.c:  XMX(0,p7G_B) = gm->xsc[p7P_N][p7P_MOVE];                    /* S->N->B, no N-tail   */
generic_viterbi.c:  for (k = 0; k <= gm->M; k++)
generic_viterbi.c:   *    vsc =  S + gm->xsc[p7P_E][p7P_MOVE] +  gm->xsc[p7P_C][p7P_MOVE];
generic_viterbi.c:   *    P  = esl_gumbel_surv((vfsc - filtersc) / eslCONST_LOG2  ,  gm->evparam[p7_VMU],  gm->evparam[p7_VLAMBDA]);
generic_viterbi.c:   *    (vsc - filtersc) /  eslCONST_LOG2 = esl_gumbel_invsurv( P, gm->evparam[p7_VMU],  gm->evparam[p7_VLAMBDA])
generic_viterbi.c:   *    vsc = filtersc + eslCONST_LOG2 * esl_gumbel_invsurv( P, gm->evparam[p7_VMU],  gm->evparam[p7_VLAMBDA])
generic_viterbi.c:   *    S = vsc - gm->xsc[p7P_E][p7P_MOVE] -  gm->xsc[p7P_C][p7P_MOVE]
generic_viterbi.c:    invP = esl_gumbel_invsurv(P, gm->evparam[p7_VMU],  gm->evparam[p7_VLAMBDA]);
generic_viterbi.c:                  - gm->xsc[p7P_E][p7P_MOVE] -  gm->xsc[p7P_C][p7P_MOVE] );
generic_viterbi.c:      float const *rsc = gm->rsc[dsq[i]];
generic_viterbi.c:      for (k = 1; k < gm->M; k++)
generic_viterbi.c:        for (k = 1; k <= gm->M; k++) {
generic_viterbi.c:        sc           =             XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];   /* J->J */
generic_viterbi.c:        XMX(i,p7G_J) = ESL_MAX(sc, XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP]);  /* E->J is E's "loop" */
generic_viterbi.c:        sc           =             XMX(i-1,p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
generic_viterbi.c:        XMX(i,p7G_C) = ESL_MAX(sc, XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_MOVE]);
generic_viterbi.c:        XMX(i,p7G_N) = XMX(i-1,p7G_N) + gm->xsc[p7P_N][p7P_LOOP];
generic_viterbi.c:        sc           =             XMX(i,p7G_N) + gm->xsc[p7P_N][p7P_MOVE];   /* N->B is N's move */
generic_viterbi.c:        XMX(i,p7G_B) = ESL_MAX(sc, XMX(i,p7G_J) + gm->xsc[p7P_J][p7P_MOVE]);  /* J->B is J's move */
generic_viterbi.c:  gx->M = gm->M;
generic_viterbi.c:  gx = p7_gmx_Create(gm->M, L);
generic_viterbi.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / (double) bench_time;
generic_viterbi.c:  printf("# M    = %d\n",   gm->M);
generic_viterbi.c:  if ((gx = p7_gmx_Create(gm->M, L))               == NULL)  esl_fatal("failed to create DP matrix");
generic_viterbi.c:  if ((gx     = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
generic_viterbi.c:  fwd = p7_gmx_Create(gm->M, sq->n);
generic_vtrace.c:  int          M   = gm->M;
generic_vtrace.c:  float const *tsc = gm->tsc;
generic_vtrace.c:    float const *rsc = (i>0 ? gm->rsc[dsq[i]] : NULL);
generic_vtrace.c:      if      (esl_FCompare(XMX(i, p7G_C), XMX(i-1, p7G_C) + gm->xsc[p7P_C][p7P_LOOP], tol) == eslOK)  scur = p7T_C; 
generic_vtrace.c:      else if (esl_FCompare(XMX(i, p7G_C), XMX(i,   p7G_E) + gm->xsc[p7P_E][p7P_MOVE], tol) == eslOK)  scur = p7T_E; 
generic_vtrace.c:      if      (esl_FCompare(XMX(i,p7G_B), XMX(i, p7G_N) + gm->xsc[p7P_N][p7P_MOVE], tol) == eslOK) scur = p7T_N;
generic_vtrace.c:      else if (esl_FCompare(XMX(i,p7G_B), XMX(i, p7G_J) + gm->xsc[p7P_J][p7P_MOVE], tol) == eslOK) scur = p7T_J;
generic_vtrace.c:      if      (esl_FCompare(XMX(i,p7G_J), XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP], tol) == eslOK) scur = p7T_J; 
generic_vtrace.c:      else if (esl_FCompare(XMX(i,p7G_J), XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP], tol) == eslOK) scur = p7T_E; 
generic_vtrace.c:  tr->M = gm->M;
generic_vtrace.c:  fwd = p7_gmx_Create(gm->M, sq->n);
hmmer.h:/* Indices for special state types in the length model, gm->xsc[x][]
hmmer.h:/* Indices for transitions from the length modeling scores gm->xsc[][x]
hmmer.h:/* Indices for transition scores gm->tsc[k][] */
hmmer.h: *   float const *tsc = gm->tsc;
hmmer.h: *   float const *rsc = gm->rsc[dsq[i]];
hmmpress.c:      om = p7_oprofile_Create(gm->M, abc);
hmmsim.c:  om = p7_oprofile_Create(gm->M, cfg->abc);
hmmsim.c:  gx = p7_gmx_Create(gm->M, L);
hmmsim.c:  ox = p7_omx_Create(gm->M, 0, L);
hmmsim.c:  gm->xsc[p7P_N][p7P_LOOP] =  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = log(bg->p1);
hmmsim.c:  gm->xsc[p7P_N][p7P_MOVE] =  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = log(1.0 - bg->p1);
itest_brute.c:  double n;             /* N->B   exp(gm->xsc[p7P_N][p7P_MOVE]) */
itest_brute.c:  double p;             /* E->C   exp(gm->xsc[p7P_E][p7P_MOVE]) */
itest_brute.c:  double q;             /* C->T   exp(gm->xsc[p7P_C][p7P_MOVE]) */
itest_brute.c:  double r;             /* J->B   exp(gm->xsc[p7P_J][p7P_MOVE]) */  
itest_brute.c:  prm->n = 1.0;      /* N->B   exp(gm->xsc[p7P_N][p7P_MOVE]) */
itest_brute.c:  prm->p = 1.0;      /* E->C   exp(gm->xsc[p7P_E][p7P_MOVE]) */
itest_brute.c:  prm->q = 1.0;      /* C->T   exp(gm->xsc[p7P_C][p7P_MOVE]) */
itest_brute.c:  prm->r = 1.0;      /* J->B   exp(gm->xsc[p7P_J][p7P_MOVE]) */
itest_brute.c:  prm->n = 0.41;      /* N->B   exp(gm->xsc[p7P_N][p7P_MOVE]) */
itest_brute.c:  prm->p = 0.43;      /* E->C   exp(gm->xsc[p7P_E][p7P_MOVE]) */
itest_brute.c:  prm->q = 0.45;      /* C->T   exp(gm->xsc[p7P_C][p7P_MOVE]) */
itest_brute.c:  prm->r = 0.47;      /* J->B   exp(gm->xsc[p7P_J][p7P_MOVE]) */
itest_brute.c:  gm->xsc[p7P_N][p7P_MOVE] = log(prm->n);
itest_brute.c:  gm->xsc[p7P_N][p7P_LOOP] = log(zerofy(1. - prm->n));
itest_brute.c:  gm->xsc[p7P_E][p7P_MOVE] = log(prm->p);
itest_brute.c:  gm->xsc[p7P_E][p7P_LOOP] = log(zerofy(1. - prm->p));
itest_brute.c:  gm->xsc[p7P_C][p7P_MOVE] = log(prm->q);
itest_brute.c:  gm->xsc[p7P_C][p7P_LOOP] = log(zerofy(1. - prm->q));
itest_brute.c:  gm->xsc[p7P_J][p7P_MOVE] = log(prm->r);
itest_brute.c:  gm->xsc[p7P_J][p7P_LOOP] = log(zerofy(1. - prm->r));
modelconfig.c:  if (gm->abc->type != hmm->abc->type) ESL_XEXCEPTION(eslEINVAL, "HMM and profile alphabet don't match");
modelconfig.c:  if (hmm->M > gm->allocM)             ESL_XEXCEPTION(eslEINVAL, "profile too small to hold HMM");
modelconfig.c:  gm->M                = hmm->M;
modelconfig.c:  gm->max_length       = hmm->max_length;
modelconfig.c:  gm->mode             = mode;
modelconfig.c:  gm->roff             = -1;
modelconfig.c:  gm->eoff             = -1;
modelconfig.c:  gm->offs[p7_MOFFSET] = -1;
modelconfig.c:  gm->offs[p7_FOFFSET] = -1;
modelconfig.c:  gm->offs[p7_POFFSET] = -1;
modelconfig.c:  if (gm->name != NULL) free(gm->name);
modelconfig.c:  if (gm->acc  != NULL) free(gm->acc);
modelconfig.c:  if (gm->desc != NULL) free(gm->desc);
modelconfig.c:  if ((status = esl_strdup(hmm->name,   -1, &(gm->name))) != eslOK) goto ERROR;
modelconfig.c:  if ((status = esl_strdup(hmm->acc,    -1, &(gm->acc)))  != eslOK) goto ERROR;
modelconfig.c:  if ((status = esl_strdup(hmm->desc,   -1, &(gm->desc))) != eslOK) goto ERROR;
modelconfig.c:  if (hmm->flags & p7H_RF)    strcpy(gm->rf,        hmm->rf);
modelconfig.c:  if (hmm->flags & p7H_MMASK) strcpy(gm->mm,        hmm->mm);
modelconfig.c:  if (hmm->flags & p7H_CONS)  strcpy(gm->consensus, hmm->consensus); /* must be present, actually, so the flag test is just for symmetry w/ other optional HMM fields */
modelconfig.c:  if (hmm->flags & p7H_CS)    strcpy(gm->cs,        hmm->cs);
modelconfig.c:  for (z = 0; z < p7_NEVPARAM; z++) gm->evparam[z] = hmm->evparam[z];
modelconfig.c:  for (z = 0; z < p7_NCUTOFFS; z++) gm->cutoff[z]  = hmm->cutoff[z];
modelconfig.c:  for (z = 0; z < p7_MAXABET;  z++) gm->compo[z]   = hmm->compo[z];
modelconfig.c:    gm->xsc[p7P_E][p7P_MOVE] = -eslCONST_LOG2;   
modelconfig.c:    gm->xsc[p7P_E][p7P_LOOP] = -eslCONST_LOG2;   
modelconfig.c:    gm->nj                   = 1.0f;
modelconfig.c:    gm->xsc[p7P_E][p7P_MOVE] = 0.0f;   
modelconfig.c:    gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;  
modelconfig.c:    gm->nj                   = 0.0f;
modelconfig.c:  for (k = 1; k < gm->M; k++) {
modelconfig.c:    tp = gm->tsc + k * p7P_NTRANS;
modelconfig.c:      rp = gm->rsc[x] + k * p7P_NR;
modelconfig.c:  for (x = 0; x < gm->abc->Kp; x++)
modelconfig.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->K)    = -eslINFINITY; /* gap symbol */
modelconfig.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-2) = -eslINFINITY; /* nonresidue symbol */
modelconfig.c:  for (k = 1; k <= hmm->M; k++) p7P_ISC(gm, k, gm->abc->Kp-1) = -eslINFINITY; /* missing data symbol */
modelconfig.c:      rp = gm->rsc[x] + k*p7P_NR;
modelconfig.c:  gm->L = 0;			/* force ReconfigLength to reconfig */
modelconfig.c: *            search. The profile has precalculated <gm->nj>, 
modelconfig.c:  pmove = (2.0f + gm->nj) / ((float) L + 2.0f + gm->nj); /* 2/(L+2) for sw; 3/(L+3) for fs */
modelconfig.c:  gm->xsc[p7P_N][p7P_LOOP] =  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = log(ploop);
modelconfig.c:  gm->xsc[p7P_N][p7P_MOVE] =  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = log(pmove);
modelconfig.c:  gm->L = L;
modelconfig.c: *            search. The profile has precalculated <gm->nj>, 
modelconfig.c:  pmove = (2.0f + gm->nj) / ((float) amino_len + 2.0f + gm->nj); /* 2/(L+2) for sw; 3/(L+3) for fs */
modelconfig.c:  gm->xsc[p7P_N][p7P_LOOP] =  gm->xsc[p7P_C][p7P_LOOP] = gm->xsc[p7P_J][p7P_LOOP] = log(ploop);
modelconfig.c:  gm->xsc[p7P_N][p7P_MOVE] =  gm->xsc[p7P_C][p7P_MOVE] = gm->xsc[p7P_J][p7P_MOVE] = log(pmove);
modelconfig.c:  gm->L = L;
modelconfig.c:  gm->xsc[p7P_E][p7P_MOVE] = -eslCONST_LOG2;   
modelconfig.c:  gm->xsc[p7P_E][p7P_LOOP] = -eslCONST_LOG2;   
modelconfig.c:  gm->nj                   = 1.0f;
modelconfig.c:  gm->xsc[p7P_E][p7P_MOVE] = -eslCONST_LOG2;   
modelconfig.c:  gm->xsc[p7P_E][p7P_LOOP] = -eslCONST_LOG2;   
modelconfig.c:  gm->nj                   = 1.0f;
modelconfig.c:  gm->xsc[p7P_E][p7P_MOVE] = 0.0f;   
modelconfig.c:  gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;  
modelconfig.c:  gm->nj                   = 0.0f;
modelconfig.c:  gm->xsc[p7P_E][p7P_MOVE] = 0.0f;   
modelconfig.c:  gm->xsc[p7P_E][p7P_LOOP] = -eslINFINITY;  
modelconfig.c:  gm->nj                   = 0.0f;
modelconfig.c:  int     M   = gm->M;    /* length of the query                                          */
modelconfig.c:  int     K   = gm->abc->K;
modelconfig.c:  int     Kp  = gm->abc->Kp;
modelconfig.c:  for (i = 1; i <= gm->M; i++) {
modelconfig.c:      if (gm->mm && gm->mm[i] == 'm')
modelconfig.c:        sc_tmp[j] = log(fwd_emissions[i*gm->abc->Kp + j] / bg->f[j]);
modelconfig.c:      gm->rsc[j][(i) * p7P_NR  + p7P_MSC] =  sc_tmp[j];
modelconfig.c: *            <gm->hmm> safely. To avoid such things, the caller
modelconfig.c:  if (gm->mode != p7_UNILOCAL) ESL_XEXCEPTION(eslEINVAL, "profile must be unilocal");
modelconfig.c:  if ((sq2 = esl_sq_CreateDigital(gm->abc))  == NULL)   { status = eslEMEM; goto ERROR; }
modelconfig.c:  if (gm->h2_mode) {
modelstats.c:  P7_GMX         *gx  = p7_gmx_Create(gm->M, L);
modelstats.c:      if (p7_gmx_GrowTo(gx, gm->M, sq->n)                 != eslOK) p7_Die("failed to grow the matrix");
mpisupport.c:    Kp = gm->abc->Kp;
mpisupport.c:    M  = gm->M;
mpisupport.c:    if ((status = esl_mpi_PackOptSize(gm->name, -1, MPI_CHAR,  comm, &sz))!= eslOK) goto ERROR;                                    n += sz;                 /* name (string)   */
mpisupport.c:    if ((status = esl_mpi_PackOptSize(gm->acc,  -1, MPI_CHAR,  comm, &sz))!= eslOK) goto ERROR;                                    n += sz;                 /* acc (string)    */
mpisupport.c:    if ((status = esl_mpi_PackOptSize(gm->desc, -1, MPI_CHAR,  comm, &sz))!= eslOK) goto ERROR;                                    n += sz;                 /* desc (string)   */
mpisupport.c:      if (MPI_Pack(&(gm->mode),                 1, MPI_INT,   *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(&(gm->L),                    1, MPI_INT,   *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->tsc,         p7P_NTRANS *M, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->rsc[0], (M+1)* Kp * p7P_NR, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->xsc[0],        p7P_NXTRANS, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->xsc[1],        p7P_NXTRANS, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->xsc[2],        p7P_NXTRANS, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->xsc[3],        p7P_NXTRANS, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(&(gm->nj),                   1, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if ((status = esl_mpi_PackOpt(gm->name, -1,  MPI_CHAR,  *buf, n, &position,  comm)) != eslOK) goto ERROR;
mpisupport.c:      if ((status = esl_mpi_PackOpt(gm->acc,  -1,  MPI_CHAR,  *buf, n, &position,  comm)) != eslOK) goto ERROR; 
mpisupport.c:      if ((status = esl_mpi_PackOpt(gm->desc, -1,  MPI_CHAR,  *buf, n, &position,  comm)) != eslOK) goto ERROR;
mpisupport.c:      if (MPI_Pack(gm->rf,                    M+2, MPI_CHAR,  *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->mm,                    M+2, MPI_CHAR,  *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed");
mpisupport.c:      if (MPI_Pack(gm->cs,                    M+2, MPI_CHAR,  *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->consensus,             M+2, MPI_CHAR,  *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->evparam,       p7_NEVPARAM, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->cutoff,        p7_NCUTOFFS, MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:      if (MPI_Pack(gm->compo,         p7_MAXABET,  MPI_FLOAT, *buf, n, &position,  comm)  != 0)     ESL_XEXCEPTION(eslESYS, "pack failed"); 
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, &(gm->mode),                   1, MPI_INT,   comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, &(gm->L),                      1, MPI_INT,   comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->tsc,            p7P_NTRANS*M, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->rsc[0], p7P_NR*(M+1)*abc->Kp, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->xsc[0],          p7P_NXTRANS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");  
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->xsc[1],          p7P_NXTRANS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");  
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->xsc[2],          p7P_NXTRANS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");  
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->xsc[3],          p7P_NXTRANS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");  
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, &(gm->nj),                     1, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");  
mpisupport.c:  if ((status = esl_mpi_UnpackOpt(  *buf, n, &position,  (void**)&(gm->name),  NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;
mpisupport.c:  if ((status = esl_mpi_UnpackOpt(  *buf, n, &position,  (void**)&(gm->acc),   NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;
mpisupport.c:  if ((status = esl_mpi_UnpackOpt(  *buf, n, &position,  (void**)&(gm->desc),  NULL, MPI_CHAR,  comm)) != eslOK) goto ERROR;
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->rf,                      M+2, MPI_CHAR,  comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->mm,                      M+2, MPI_CHAR,  comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->cs,                      M+2, MPI_CHAR,  comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->consensus,               M+2, MPI_CHAR,  comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->evparam,         p7_NEVPARAM, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->cutoff,          p7_NCUTOFFS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  if (MPI_Unpack(*buf, n, &position, gm->compo,           p7_NCUTOFFS, MPI_FLOAT, comm) != 0) ESL_XEXCEPTION(eslESYS, "unpack failed");
mpisupport.c:  gm->abc = abc;
mpisupport.c:  gm->M   = M;
nhmmer.c:            if ( esl_abc_XIsResidue(om->abc,j) &&  gm->rsc[j][(i) * p7P_NR     + p7P_MSC]   > max_score)   max_score   = gm->rsc[j][(i) * p7P_NR     + p7P_MSC];
optacc_frameshift.c: *            <gm->M> by <pp->L> comparison. The routine fills this in
optacc_frameshift.c: *            gx    - RESULT: caller provided DP matrix for <gm->M> by <L> 
optacc_frameshift.c:  float const *tsc  = gm->tsc;
optacc_frameshift.c:  int          M    = gm->M;
optacc_frameshift.c:      t1 = ( (gm->xsc[p7P_J][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t2 = ( (gm->xsc[p7P_E][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t1 = ( (gm->xsc[p7P_C][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t2 = ( (gm->xsc[p7P_E][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t1 = ( (gm->xsc[p7P_N][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t1 = ( (gm->xsc[p7P_N][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      t2 = ( (gm->xsc[p7P_J][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  tr->M = gm->M;
optacc_frameshift.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
optacc_frameshift.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
optacc_frameshift.c:  float const *tsc  = gm->tsc;	/* so TSCDELTA() macro works */
optacc_frameshift.c:  float  t1   =  ( (gm->xsc[p7P_C][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  float  t2   =  ( (gm->xsc[p7P_E][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  else if(i < gm->L)  path[1] = t1 * (XMX(i-2, p7G_C) + pp->xmx[(i+1)*p7G_NXCELLS + p7G_C]);
optacc_frameshift.c:  else if(i < gm->L-1)  path[2] = t1 * (XMX(i-1, p7G_C) + pp->xmx[(i+2)*p7G_NXCELLS + p7G_C]);
optacc_frameshift.c:  float  t1   = ( (gm->xsc[p7P_J][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  float  t2   = ( (gm->xsc[p7P_E][p7P_LOOP] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:      *ret_k = gm->M;
optacc_frameshift.c:      return ((MMX(i,gm->M) >= DMX(i,gm->M)) ? p7T_M : p7T_D);
optacc_frameshift.c:  for (k = 1; k <= gm->M; k++)
optacc_frameshift.c:  float t1 = ( (gm->xsc[p7P_N][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  float t2 = ( (gm->xsc[p7P_J][p7P_MOVE] == -eslINFINITY) ? FLT_MIN : 1.0);
optacc_frameshift.c:  gx1 = p7_gmx_Create(gm->M, L);
optacc_frameshift.c:  gx2 = p7_gmx_Create(gm->M, L);
optacc_frameshift.c:  Mcs        = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
optacc_frameshift.c:  printf("# M    = %d\n", gm->M);
optacc_frameshift.c:  gx1 = p7_gmx_Create(gm->M, sq->n);
optacc_frameshift.c:  gx2 = p7_gmx_Create(gm->M, sq->n);
p7_alidisplay.c:  char          *alphaAmino = gm->abc->sym;
p7_alidisplay.c:  if (gm->rf[0]  != 0)    n += (z2-z1+2);   /* optional reference line              */
p7_alidisplay.c:  if (gm->mm[0]  != 0)    n += (z2-z1+2);   /* optional reference line              */
p7_alidisplay.c:  if (gm->cs[0]  != 0)    n += (z2-z1+2);   /* optional structure line              */
p7_alidisplay.c:  hmm_namelen = strlen(gm->name);                           n += hmm_namelen + 1;
p7_alidisplay.c:  hmm_acclen  = (gm->acc  != NULL ? strlen(gm->acc)  : 0);  n += hmm_acclen  + 1;
p7_alidisplay.c:  hmm_desclen = (gm->desc != NULL ? strlen(gm->desc) : 0);  n += hmm_desclen + 1;
p7_alidisplay.c:  if (gm->rf[0]  != 0) { ad->rfline = ad->mem + pos; pos += z2-z1+2; } else { ad->rfline = NULL; }
p7_alidisplay.c:  if (gm->cs[0]  != 0) { ad->csline = ad->mem + pos; pos += z2-z1+2; } else { ad->csline = NULL; }
p7_alidisplay.c:  strcpy(ad->hmmname, gm->name);
p7_alidisplay.c:  if (gm->acc  != NULL) strcpy(ad->hmmacc,  gm->acc);  else ad->hmmacc[0]  = 0;
p7_alidisplay.c:  if (gm->desc != NULL) strcpy(ad->hmmdesc, gm->desc); else ad->hmmdesc[0] = 0;
p7_alidisplay.c:  ad->M       = gm->M;
p7_alidisplay.c:    for (z = z1; z <= z2; z++) ad->rfline[z-z1] = ((tr->st[z] == p7T_I) ? '.' : gm->rf[tr->k[z]]);
p7_alidisplay.c:    for (z = z1; z <= z2; z++) ad->mmline[z-z1] = ((tr->st[z] == p7T_I) ? '.' : gm->mm[tr->k[z]]);
p7_alidisplay.c:    for (z = z1; z <= z2; z++) ad->csline[z-z1] = ((tr->st[z] == p7T_I) ? '.' : gm->cs[tr->k[z]]);
p7_alidisplay.c:        ad->model[z-z1] = gm->consensus[k];
p7_alidisplay.c:	        rsc = gm->rsc[a]; 
p7_alidisplay.c:	        rsc = gm->rsc[a]; 
p7_alidisplay.c:	        rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	     rsc = gm->rsc[a]; 
p7_alidisplay.c:	if      (x == esl_abc_DigitizeSymbol(gm->abc, gm->consensus[k])) ad->mline[z-z1] = ad->model[z-z1];
p7_alidisplay.c:	ad->model [z-z1] = gm->consensus[k];
p7_alidisplay.c:  om = p7_oprofile_Create(gm->M, abc);
p7_alidisplay.c:  om = p7_oprofile_Create(gm->M, abc);
p7_domaindef.c:  int            saveL     = gm->L;    /* need to be able to restore original <gm> config */
p7_domaindef.c:  int            save_mode = gm->mode;
p7_domaindef.c:  int saveL     = gm->L;	/* Save the length config of <om>; will restore upon return */
p7_domaindef.c:  int save_mode = gm->mode;	/* Likewise for the mode. */
p7_domaindef.c:   printf("gm L %d\n", gm->L);  
p7_domaindef.c:	p7_gmx_fs_GrowTo(fwd, gm->M, j-i+1);
p7_domaindef.c:        p7_gmx_GrowTo(bck, gm->M, j-i+1);
p7_domaindef.c:  int     K   = gm->abc->K;
p7_domaindef.c:    esl_vec_FSet (bgf_arr, gm->abc->K, 0);
p7_domaindef.c:    esl_vec_FNorm(bgf_arr, gm->abc->K);
p7_domaindef.c:    orig_L = gm->L;
p7_domaindef.c:    emit_sc = Codon_Emissions_Create(gm->rsc, ntsq->dsq + i-1, gcode, gm->M, Ld, indel_cost);
p7_domaindef.c:  gxpp = p7_gmx_fs_Create(gm->M, Ld);
p7_domaindef.c:  fwd = p7_omx_Create(gm->M, sq->n, sq->n);
p7_domaindef.c:  bck = p7_omx_Create(gm->M, sq->n, sq->n);
p7_domaindef.c:  fwd  = p7_gmx_Create(gm->M, L0);
p7_domaindef.c:  bck  = p7_gmx_Create(gm->M, L0);
p7_domaindef.c:  gxf  = p7_gmx_Create(gm->M, L0);
p7_domaindef.c:  gxb  = p7_gmx_Create(gm->M, L0);
p7_domaindef.c:      p7_gmx_GrowTo(fwd, gm->M, sq->n);
p7_domaindef.c:      p7_gmx_GrowTo(bck, gm->M, sq->n);
p7_gmx.c:  P7_GMX       *gx1 = p7_gmx_Create(gm->M, L);
p7_gmx.c:  if (esl_rsq_xfIID(r, bg->f, gm->abc->K, L, dsq) != eslOK) esl_fatal(msg);
p7_gmx.c:  if (p7_gmx_GrowTo(gx2, gm->M, L)                != eslOK) esl_fatal(msg);
p7_gmx_fs.c:  P7_GMX       *gx1 = p7_gmx_Create(gm->M, L);
p7_gmx_fs.c:  if (esl_rsq_xfIID(r, bg->f, gm->abc->K, L, dsq) != eslOK) esl_fatal(msg);
p7_gmx_fs.c:  if (p7_gmx_GrowTo(gx2, gm->M, L)                != eslOK) esl_fatal(msg);
p7_hmmfile.c:    om = p7_oprofile_Create(gm->M, abc);
p7_null3.c:  gx1 = p7_gmx_Create(gm->M, L);  
p7_null3.c:  gx2 = p7_gmx_Create(gm->M, L);
p7_null3.c:  Mcs  = (double) N * (double) L * (double) gm->M * 1e-6 / w->user;
p7_null3.c:  printf("# M    = %d\n", gm->M);
p7_null3.c:  esl_rsq_xfIID(r, bg->f, gm->abc->K, L, dsq); /* sample a random digital seq of length L */
p7_null3.c:  for (x = 0; x < gm->abc->K; x++)
p7_null3.c:  sum = esl_vec_FSum(null2, gm->abc->K);
p7_null3.c:  fwd  = p7_gmx_Create(gm->M, L);
p7_null3.c:  bck  = p7_gmx_Create(gm->M, L);
p7_pipeline.c:  emit_sc = Codon_Emissions_Create(gm->rsc, subseq, gcode, gm->M, window_len, indel_cost);
p7_pipeline.c:  p7_gmx_fs_GrowTo(pli->gxf, gm->M, window_len);
p7_pipeline.c:  P = esl_exp_surv(seq_score,  gm->evparam[p7_FTAU],  gm->evparam[p7_FLAMBDA]);
p7_pipeline.c:  p7_gmx_GrowTo(pli->gxb, gm->M, window_len);
p7_pipeline.c:      p7_pli_computeAliScores(pli->ddef->dcl + d, dnasq->dsq, data, gm->abc->Kp);
p7_pipeline.c:  lnP =  esl_exp_logsurv (seq_score,  gm->evparam[p7_FTAU], gm->evparam[p7_FLAMBDA]);
p7_pipeline.c:        if ((status  = esl_strdup(gm->name, -1, &(hit->name)))  != eslOK) esl_fatal("allocation failure");
p7_pipeline.c:        if ((status  = esl_strdup(gm->acc,  -1, &(hit->acc)))   != eslOK) esl_fatal("allocation failure");
p7_pipeline.c:        if ((status  = esl_strdup(gm->desc, -1, &(hit->desc)))  != eslOK) esl_fatal("allocation failure");
p7_pipeline.c:      hit->pre_lnP    = esl_exp_logsurv (hit->pre_score,  gm->evparam[p7_FTAU], gm->evparam[p7_FLAMBDA]);
p7_pipeline.c:      hit->sum_lnP    = esl_exp_logsurv (hit->sum_score,  gm->evparam[p7_FTAU], gm->evparam[p7_FLAMBDA]);
p7_pipeline.c:        hit->dcl[d].lnP      = esl_exp_logsurv (hit->dcl[d].bitscore,  gm->evparam[p7_FTAU], gm->evparam[p7_FLAMBDA]);
p7_pipeline.c:  pli_tmp->gm = p7_profile_Create(gm->M, om->abc);
p7_pipeline.c:  ESL_ALLOC(pli_tmp->scores, sizeof(float) * gm->abc->Kp * 4); //allocation of space to store scores that will be used in p7_oprofile_Update(Fwd|Vit|MSV)EmissionScores
p7_pipeline.c:  ESL_ALLOC(pli_tmp->fwd_emissions_arr, sizeof(float) *  gm->abc->Kp * (gm->M+1));
p7_pipeline.c:      pli_tmp->tmpseq = esl_sq_CreateDigital(gm->abc);
p7_profile.c: *            reference pointer <gm->abc> is set to <abc>.
p7_profile.c:  gm->tsc       = NULL;
p7_profile.c:  gm->rsc       = NULL;
p7_profile.c:  gm->rf        = NULL;
p7_profile.c:  gm->mm        = NULL;
p7_profile.c:  gm->cs        = NULL;
p7_profile.c:  gm->consensus = NULL;
p7_profile.c:  ESL_ALLOC(gm->tsc,       sizeof(float)   * allocM * p7P_NTRANS); 
p7_profile.c:  ESL_ALLOC(gm->rsc,       sizeof(float *) * abc->Kp);
p7_profile.c:  ESL_ALLOC(gm->rf,        sizeof(char)    * (allocM+2)); /* yes, +2: each is (0)1..M, +trailing \0  */
p7_profile.c:  ESL_ALLOC(gm->mm,        sizeof(char)    * (allocM+2));
p7_profile.c:  ESL_ALLOC(gm->cs,        sizeof(char)    * (allocM+2));
p7_profile.c:  ESL_ALLOC(gm->consensus, sizeof(char)    * (allocM+2));
p7_profile.c:  gm->rsc[0] = NULL;
p7_profile.c:  ESL_ALLOC(gm->rsc[0], sizeof(float) * abc->Kp * (allocM+1) * p7P_NR);
p7_profile.c:    gm->rsc[x] = gm->rsc[0] + x * (allocM+1) * p7P_NR;
p7_profile.c:  esl_vec_FSet(gm->tsc, p7P_NTRANS, -eslINFINITY);     /* node 0 nonexistent, has no transitions  */
p7_profile.c:  esl_vec_FSet(gm->rsc[x], (allocM+1)*p7P_NR, -eslINFINITY);
p7_profile.c:  esl_vec_FSet(gm->rsc[x], (allocM+1)*p7P_NR, -eslINFINITY);
p7_profile.c:  gm->mode             = p7_NO_MODE;
p7_profile.c:  gm->L                = 0;
p7_profile.c:  gm->allocM           = allocM;
p7_profile.c:  gm->M                = 0;
p7_profile.c:  gm->max_length       = -1;
p7_profile.c:  gm->nj               = 0.0f;
p7_profile.c:  gm->roff             = -1;
p7_profile.c:  gm->eoff             = -1;
p7_profile.c:  gm->offs[p7_MOFFSET] = -1;
p7_profile.c:  gm->offs[p7_FOFFSET] = -1;
p7_profile.c:  gm->offs[p7_POFFSET] = -1;
p7_profile.c:  gm->name             = NULL;
p7_profile.c:  gm->acc              = NULL;
p7_profile.c:  gm->desc             = NULL;
p7_profile.c:  gm->rf[0]            = 0;     /* RF line is optional annotation; this flags that it's not set yet */
p7_profile.c:  gm->mm[0]            = 0;     /* likewise for MM annotation line */
p7_profile.c:  gm->cs[0]            = 0;     /* likewise for CS annotation line */
p7_profile.c:  gm->consensus[0]     = 0;
p7_profile.c:  for (x = 0; x < p7_NEVPARAM; x++) gm->evparam[x] = p7_EVPARAM_UNSET;
p7_profile.c:  for (x = 0; x < p7_NCUTOFFS; x++) gm->cutoff[x]  = p7_CUTOFF_UNSET;
p7_profile.c:  for (x = 0; x < p7_MAXABET;  x++) gm->compo[x]   = p7_COMPO_UNSET;
p7_profile.c:  gm->abc         = abc;
p7_profile.c:  if ((g2 = p7_profile_Create(gm->allocM, gm->abc)) == NULL) return NULL;
p7_profile.c:  for (i = 1; i <= gm->M; i++) {
p7_profile.c:    for (j=0; j<gm->abc->Kp; j++) {
p7_profile.c:      arr[i*gm->abc->Kp + j] =  bg->f[j] * exp( gm->rsc[j][(i) * p7P_NR     + p7P_MSC]);
p7_profile.c:  for (x = 0; x <= gm->abc->K; x++)                esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0);   /* canonicals    */
p7_profile.c:  for (x = gm->abc->K+1; x <= gm->abc->Kp-3; x++)  esl_vec_FSet(gm->rsc[x], (gm->M+1)*p7P_NR, 0.0);   /* noncanonicals */
p7_profile.c:  if (gm->name != NULL) { free(gm->name); gm->name = NULL; }
p7_profile.c:  if (gm->acc  != NULL) { free(gm->acc);  gm->acc  = NULL; }
p7_profile.c:  if (gm->desc != NULL) { free(gm->desc); gm->desc = NULL; }
p7_profile.c:  gm->rf[0]        = 0;
p7_profile.c:  gm->mm[0]        = 0;
p7_profile.c:  gm->cs[0]        = 0;
p7_profile.c:  gm->consensus[0] = 0;
p7_profile.c:  gm->mode = p7_NO_MODE;
p7_profile.c:  gm->L    = 0;
p7_profile.c:  gm->M    = 0;
p7_profile.c:  gm->nj   = 0.0f;
p7_profile.c:  gm->roff             = -1;
p7_profile.c:  gm->eoff             = -1;
p7_profile.c:  gm->offs[p7_MOFFSET] = -1;
p7_profile.c:  gm->offs[p7_FOFFSET] = -1;
p7_profile.c:  gm->offs[p7_POFFSET] = -1;
p7_profile.c:  n += sizeof(float)   * gm->allocM * p7P_NTRANS;             /* gm->tsc       */
p7_profile.c:  n += sizeof(float *) * gm->abc->Kp;	                      /* gm->rsc       */
p7_profile.c:  n += sizeof(char)    * (gm->allocM+2);	              /* gm->rf        */
p7_profile.c:  n += sizeof(char)    * (gm->allocM+2);                /* gm->mm        */
p7_profile.c:  n += sizeof(char)    * (gm->allocM+2);	              /* gm->cs        */
p7_profile.c:  n += sizeof(char)    * (gm->allocM+2);	              /* gm->consensus */
p7_profile.c:  n += sizeof(float) * gm->abc->Kp * (gm->allocM+1) * p7P_NR; /* gm->rsc[0]    */
p7_profile.c:    if (gm->rsc   != NULL && gm->rsc[0] != NULL) free(gm->rsc[0]);
p7_profile.c:    if (gm->tsc       != NULL) free(gm->tsc);
p7_profile.c:    if (gm->rsc       != NULL) free(gm->rsc);
p7_profile.c:    if (gm->name      != NULL) free(gm->name);
p7_profile.c:    if (gm->acc       != NULL) free(gm->acc);
p7_profile.c:    if (gm->desc      != NULL) free(gm->desc);
p7_profile.c:    if (gm->rf        != NULL) free(gm->rf);
p7_profile.c:    if (gm->mm        != NULL) free(gm->mm);
p7_profile.c:    if (gm->cs        != NULL) free(gm->cs);
p7_profile.c:    if (gm->consensus != NULL) free(gm->consensus);
p7_profile.c:  if (gm->mode == p7_UNILOCAL || gm->mode == p7_LOCAL) return TRUE;
p7_profile.c:  if (gm->mode == p7_LOCAL || gm->mode == p7_GLOCAL) return TRUE;
p7_profile.c:    case p7T_B: tsc =  gm->xsc[p7P_N][p7P_MOVE]; break;
p7_profile.c:    case p7T_N: tsc =  gm->xsc[p7P_N][p7P_LOOP]; break;
p7_profile.c:      if (k1 != gm->M && ! p7_profile_IsLocal(gm)) ESL_EXCEPTION(eslEINVAL, "local end transition (M%d of %d) in non-local model", k1, gm->M);
p7_profile.c:      if (k1 != gm->M && ! p7_profile_IsLocal(gm)) ESL_EXCEPTION(eslEINVAL, "local end transition (D%d of %d) in non-local model", k1, gm->M);
p7_profile.c:    case p7T_C: tsc = gm->xsc[p7P_E][p7P_MOVE]; break;
p7_profile.c:    case p7T_J: tsc = gm->xsc[p7P_E][p7P_LOOP]; break;
p7_profile.c:    case p7T_B: tsc = gm->xsc[p7P_J][p7P_MOVE]; break;
p7_profile.c:    case p7T_J: tsc = gm->xsc[p7P_J][p7P_LOOP]; break;
p7_profile.c:    case p7T_T:  tsc = gm->xsc[p7P_C][p7P_MOVE]; break;
p7_profile.c:    case p7T_C:  tsc = gm->xsc[p7P_C][p7P_LOOP]; break;
p7_profile.c:  ESL_ALLOC(pstart, sizeof(double) * (gm->M+1));
p7_profile.c:      for (k = 1; k <= gm->M; k++)
p7_profile.c:	pstart[k] = exp(p7P_TSC(gm, k-1, p7P_BM)) * (gm->M - k + 1); /* multiply p_ij by the number of exits j */
p7_profile.c:      for (k = 1; k <= gm->M; k++)
p7_profile.c:  if (esl_vec_DValidate(pstart, gm->M+1, tol, NULL) != eslOK) ESL_XFAIL(eslFAIL, errbuf, "profile entry distribution is not normalized properly");
p7_scoredata.c:  //gather values from gm->rsc into a succinct 2D array
p7_scoredata.c:          data->ssv_scores_f[i*K + j] = gm->rsc[j][(i) * p7P_NR     + p7P_MSC];
p7_scoredata.c:  for (x = 0; x < gm->abc->K; x++)  max = ESL_MAX(max, esl_vec_FMax(gm->rsc[x], (gm->M+1)*2));
p7_spensemble.c:  fwd = p7_omx_Create(gm->M, sq->n, sq->n);
p7_trace.c:	      fprintf(fp, " %c", gm->abc->sym[xi]);
p7_trace.c:	      fprintf(fp, " %c", (char) tolower((int) gm->abc->sym[xi]));
p7_trace.c:	      fprintf(fp, " %c", (char) tolower((int) gm->abc->sym[xi]));
show_translated_sequence:p7_pipeline.c:  p7_gmx_fs_GrowTo(pli->gxf, gm->M, window_len);
show_translated_sequence:p7_pipeline.c:  p7_gmx_GrowTo(pli->gxb, gm->M, window_len);
show_translated_sequence:p7_pipeline.c:      p7_pli_computeAliScores(pli->ddef->dcl + d, dnasq->dsq, data, gm->abc->Kp);
stotrace_frameshift.c:  int     M   = gm->M;
stotrace_frameshift.c:  float const *tsc  = gm->tsc;
stotrace_frameshift.c:	sc[0] = XMX(i-3, p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
stotrace_frameshift.c:	sc[1] = XMX(i-2, p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
stotrace_frameshift.c:	sc[2] = XMX(i-1, p7G_C) + gm->xsc[p7P_C][p7P_LOOP];
stotrace_frameshift.c:	sc[3] = XMX(i,   p7G_E) + gm->xsc[p7P_E][p7P_MOVE];
stotrace_frameshift.c:	sc[0] = XMX(i, p7G_N) + gm->xsc[p7P_N][p7P_MOVE];
stotrace_frameshift.c:	sc[1] = XMX(i, p7G_J) + gm->xsc[p7P_J][p7P_MOVE];
stotrace_frameshift.c:	sc[0] = XMX(i-3,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];
stotrace_frameshift.c:	sc[1] = XMX(i-2,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];
stotrace_frameshift.c:	sc[2] = XMX(i-1,p7G_J) + gm->xsc[p7P_J][p7P_LOOP];
stotrace_frameshift.c:	sc[3] = XMX(i,  p7G_E) + gm->xsc[p7P_E][p7P_LOOP];
stotrace_frameshift.c:  tr->M = gm->M;
stotrace_frameshift.c:  fwd = p7_gmx_Create(gm->M, L);
stotrace_frameshift.c:  if ((gx     = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal("matrix creation failed");
stotrace_frameshift.c:  fwd = p7_gmx_Create(gm->M, sq->n);
